1. Paradigmas de ProgramaciÃ³n Un paradigma de programaciÃ³n es un conjunto de ideas que describe una forma de entender la construcciÃ³n de programa. Estas ideas nos permiten pensar y estructurar el cÃ³digo de distintas formas. Ninguna forma es mejor que otra,si no que son Ãºtiles o no para una circunstancia dada o para resolver un problema dado. Existen lenguajes que se concentran en las ideas de un Ãºnico paradigma asÃ­ como hay otros que permiten la combinaciÃ³n de ideas provenientes de distintos paradigmas.

2. ProgramaciÃ³n Orientada a Objetos En particular el paradigma de ProgramaciÃ³n Orientada a Objetos (POO) es un estilo o una forma de pensar los programas en la cual se estructura un programa construyendo piezas simples y reutilizables de cÃ³digo para crear instancias individuales de objetos.

Un programa basado en este paradigma es un conjunto de objetos que interactÃºan entre sÃ­ en un ambiente mandÃ¡ndose mensajes para lograr un objetivo determinado.

3. Objetos y mensajes Un objeto es un ente computacional que con el que podemos comunicarnos mediante mensajes y puede (o no) tener un estado interno (referencias a otros objetos).

Â¡Veamos un ejemplo concreto que nos ayude a entender un poco mÃ¡s! Imaginemos que somos ornitÃ³logos y ornitÃ³logas que estudiamos el comportamiento de las aves, y Pepita es una golondrina que tenemos en nuestro conjunto de aves:

from aves import pepita
Â¿QuÃ© caracterÃ­sticas tendrÃ¡ Pepita? Â¿QuÃ© sabe hacer? Â¿SerÃ¡ distinto de lo que hacen otras aves? Por ejemplo Â¿SabrÃ¡ volar_en_circulos?

pepita.volar_en_circulos()
Â¿SabrÃ¡ cantar_boleros?

pepita.cantar_boleros()
# AttributeError: 'Golondrina' object has no attribute 'cantar_boleros'
Â¡Ups, no! Parece que no sabe cantar voleros ğŸ˜– Â¿Y sabrÃ¡ comer_alpiste?

pepita.comer_alpiste()
# TypeError: comer_alpiste() missing 1 required positional argument: 'gramos'
ğŸ˜± Â¡Ups! sÃ­, pero tenemos que decirle cuantos gramos de alpiste queremos que coma:

pepita.comer_alpiste(10)
ğŸ’¡ FormalizaciÃ³n:
pepita es un objeto, y como todo objeto, entiende algunos mensajes. En particular, nuestra golondrina entiende los mensajes comer_alpiste y volar_en_circulos, pero no entiende cantar_boleros (ni casi ninguna otra cosa que se te ocurra ğŸ˜‰).

En otras palabras, pepita sabe comer alpiste y volar en circulos.

Por otro lado, aprendimos que si le pedimos a un objeto que haga cosas que no sabe hacer, Ã©ste se rehusarÃ¡.

Â¿Y quÃ© pasa cuando le enviamos estos mensajes? Â¡Porque es de esperar que pepita no tenga infinita energÃ­a para hacer todo lo que le pidamos! Sin embargo puede saber cuanta es la energia que le queda:

pepita.energia
ğŸ¯ Sabiendo esto, Â¿te animÃ¡s a averiguar cÃ³mo queda la energia despuÃ©s de hacerla comer alpiste? Â¿y despuÃ©s de hacerla volar en cÃ­rculos?

Como vemos, cada vez que hacemos que pepita coma y vuele, su energia cambia.

ğŸ’¡ FormalizaciÃ³n: los objetos pueden tener estado (en el caso de pepita, su estado es la energÃ­a), el cual puede cambiar a lo largo del tiempo. El estado es el conjunto de atributos de un objeto.

ğŸ¯ Â¿Te animÃ¡s a averiguar segÃºn quÃ© formula?

ğŸ’¡ FormalizaciÃ³n: cada vez que un objeto recibe un mensaje, hace algo, reaccionando al mismo. Por tanto, decimos que los objetos tienen un cierto comportamiento (por ejemplo, cuando pepita come alpiste, su energia sube en tantas unidades como los gramos ingeridos)

4. Ambientes e interfaces

pepita no es nuestra Ãºnica golodrina. TambiÃ©n contamos con anastasia. Â¿TendrÃ¡ su misma energia?

anastasia.energia
pepita.energia
anastasia es otro objeto, y como tal, cuenta con su propio estado. Por eso es que si bien las dos tienen energia, presentan valores diferentes. Â¿QuÃ© cosas sabrÃ¡ hacer anastasia?

anastasia.volar_en_circulos()
anastasia.comer_alpiste(10)
Como anastasia es otra golondrina, sabe hacer las mismas cosas que pepita.

ğŸ’¡ FormalizaciÃ³n: llamaremos ambiente al contexto en el que el viven los objetos, tienen su estado y pueden entender mensajes. En un mismo ambiente podemos contar con varios objetos, como por ejemplo, pepita y anastasia. En otras palabras es el mundo que los objetos habitan y en que se relacionan. Cada vez que apretamos play en replit, o le damos reset en colab, o cerramos nuestro intÃ©rprete de python en nuestra computadora y lo volvemos a iniciar, estamos destruyendo ese mundo y volviendo a empezar.

Pero no sÃ³lo contamos con pepita y anastasia, sino tambiÃ©n con roberta. Â¿CuÃ¡nta energÃ­a tendrÃ¡ inicialmente?

roberta.energia
ğŸ˜± Ohh, Â¡tiene mucha energia! Y tambiÃ©n sabrÃ¡ volar en cÃ­rculos, Â¿no?

roberta.volar_en_circulos()
roberta.energia
Bien, aunque como vemos perdiÃ³ sÃ³lo una unidad de energÃ­a, pese a que anastasia y pepita gastan 10 al hacerlo. Parece que las tres saben hacer lo mismo, pero roberta lo hace de forma diferente.

ğŸ’¡ FormalizaciÃ³n: no todos los objetos tienen que reaccionar de igual forma a los mismos mensajes. En otras palabras, no todos los objetos tienen por quÃ© comportarse igual.

Â¿Y quÃ© hay sobre comer_alpiste?

roberta.comer_alpiste(10)
Ey, Â¡no le gusta el alpiste! Pero nos dijeron que sÃ­ le gusta comer peces:

roberta.comer_peces(2)
roberta.energia
ğŸ’¡ FormalizaciÃ³n: no todos los objetos tienen quÃ© entender los mismos mensajes. Por ejemplo roberta no entiende comer_alpiste, pero sÃ­ entiende comer_peces (que anastasia y pepita no entienden, si no nos creÃ©s podÃ©s comprobarlo vos ğŸ˜„). Al conjunto de mensajes que cada objeto expone lo llamaremos interfaz, la cual puede ser (y tÃ­picamente serÃ¡) diferente para cada objeto.

QuÃ© rara es nuestra nueva golondrina, Â¿no? Â¡Es que no es una Golondrina! Â¡Es un dragÃ³n! ğŸ”¥

roberta.escupir_fuego()
PerdÃ³n, esperamos no haber quemado nada ğŸ™ˆ

5. Calses y polimorfismo

Momento, Â¿y cÃ³mo estÃ¡n definidas pepita, anastasia y roberta? Â¿DÃ³nde dice quÃ© saber hacer cada una y cÃ³mo?

En el paradigma de objetos, los mismos se crean a partir de moldes llamados clases, que sirven para dar vida a objetos que se comporten de igual forma. Por ejemplo nuestras golondrinas pepita y anastasia se crearÃ¡n de la siguiente forma....

pepita = Golondrina(100)
anastasia = Golondrina(200)
... partir de una clase llamada Golondrina que se verÃ¡ asÃ­:

class Golondrina:
  def __init__(self, energia):
    self.energia = energia

  def comer_alpiste(self, gramos):
    self.energia += 4 * gramos

  def volar_en_circulos(self):
    self.volar(0)

  def volar(self, kms):
    self.energia -= 10 + kms
ğŸ’¡ FormalizaciÃ³n: al acto de crear un objeto a partir de una clase se lo denomina instanciaciÃ³n, y por tanto a los objetos tambiÃ©n se los denomina instancias (de una clase particular). Por ejemplo, pepita es una instancia (de la clase Golondrina).

Si bien el tÃ©rmino instancia quizÃ¡s no nos diga mucho, en este contexto significa "ejemplo", dado que cada golondrina como pepita o anastasia son ejemplo concretos (es decir, casos particulares) de la idea mÃ¡s general de una Golondrina.

Como vemos, una clase es nuevo tipo de definiciÃ³n, que se suma a las funciones y procedimientos que ya conocÃ­amos. Se escribe mediante la palabra reservada class, seguida de un nombre y :. Dentro de ella encontraremos los mÃ©todos, que son el cÃ³digo que especifica cÃ³mo se comportarÃ¡ un objeto cuando reciba un mensaje.

ğŸ“Nota: sÃ­, los mÃ©todos se definen usando la misma palabra clave def que usabamos para funciones y procedimientos. Sin embargo, no son lo mismo: como podemos ver los mÃ©todos siempre estÃ¡n "dentro" de una clase, y ademÃ¡s tienen como primer parÃ¡metro self. El self representa la instancia de la clase. Al usar la palabra clave "self" podemos acceder a los atributos y mÃ©todos de la clase en Python. MÃ¡s sobre esto, en breve.

DesafÃ­o: Ahora te toca a vos!

Hacer esta_debil: si tienen menos de 10 puntos de energia (golondrinas) o 50 (dragones)
Hacer esta_feliz: si tiene mÃ¡s de 500 puntos de eneria (sin importar cuÃ¡l)
Hace a hipo, entrenador de dragones: sabe aceptar a dragones y luego hacerlos entrenar, haciendoles dar 20 vueltas en circulos y luego comer su comida favorita hasta saciarse (3 peces)
6. Interfaces compartidas

Entonces, Â¿pepita y roberta se comportan igual? Â¡No! Â¿Y tienen la misma interfaz? Â¡Tampoco! Pero sÃ­ tienen una parte comÃºn; en otras palabras comparten (parcialmente) una interfaz:

ğŸŒ¾ comer_alpiste	ğŸŸ comer_peces	ğŸ”¥ escupir_fuego	âœˆï¸ volar	ğŸ”„ volar_en_circulos
pepita	âœ…ï¸			âœ…ï¸	âœ…ï¸
anastasia	âœ…ï¸			âœ…ï¸	âœ…ï¸
roberta		âœ…ï¸	âœ…ï¸	âœ…ï¸	âœ…ï¸
7. Clases

Momento, Â¿y cÃ³mo estÃ¡n definidas pepita, anastasia y roberta? Â¿DÃ³nde dice quÃ© saber hacer cada una y cÃ³mo?

En el paradigma de objetos, los mismos se crean a partir de moldes llamados clases, que sirven para dar vida a objetos que se comporten de igual forma. Por ejemplo nuestras golondrinas pepita y anastasia se crearÃ¡n de la siguiente forma....

pepita = Golondrina(100)
anastasia = Golondrina(200)
... partir de una clase llamada Golondrina que se verÃ¡ asÃ­:

class Golondrina:
  def __init__(self, energia):
    self.energia = energia

  def comer_alpiste(self, gramos):
    self.energia += 4 * gramos

  def volar_en_circulos(self):
    self.volar(0)

  def volar(self, kms):
    self.energia -= 10 + kms
ğŸ’¡ FormalizaciÃ³n: al acto de crear un objeto a partir de una clase se lo denomina instanciaciÃ³n, y por tanto a los objetos tambiÃ©n se los denomina instancias (de una clase particular). Por ejemplo, pepita es una instancia (de la clase Golondrina).

Si bien el tÃ©rmino instancia quizÃ¡s no nos diga mucho, en este contexto significa "ejemplo", dado que cada golondrina como pepita o anastasia son ejemplo concretos (es decir, casos particulares) de la idea mÃ¡s general de una Golondrina.

Como vemos, una clase es nuevo tipo de definiciÃ³n, que se suma a las funciones y procedimientos que ya conocÃ­amos. Se escribe mediante la palabra reservada class, seguida de un nombre y :. Dentro de ella encontraremos los mÃ©todos, que son el cÃ³digo que especifica cÃ³mo se comportarÃ¡ un objeto cuando reciba un mensaje.

ğŸ“ Nota: sÃ­, los mÃ©todos se definen usando la misma palabra clave def que usabamos para funciones y procedimientos. Sin embargo, no son lo mismo: como podemos ver los mÃ©todos siempre estÃ¡n "dentro" de una clase, y ademÃ¡s tienen como primer parÃ¡metro self. MÃ¡s sobre esto, en breve.

8. Parecidos pero distintos: mÃ©todos vs funciones

Tomemos este mÃ©todo como ejemplo:

class Golondrina:
  def comer_alpiste(self, gramos):
    self.energia = self.energia + 4 * gramos
ğŸ‘€ Ojo, porque los mÃ©todos y las funciones, si bien se ven parecidos, no son lo mismo.

Las funciones se invocan como funcion(argumentos), pero los mÃ©todos se evaluan a travÃ©s el envio de mensajes como objeto.mensaje(argumentos)
los mÃ©todos tienen siempre declaran como primer parÃ¡metro self, las funciones no
los mÃ©todos siempre van dentro de un class, mientras que las funciones van por fuera
HabrÃ¡n notado que una diferencia importante entre una funciÃ³n y un mÃ©todo es el parÃ¡metro self (en inglÃ©s, si mismo) que reciben todos los mÃ©todos en su definiciÃ³n. Este parÃ¡metro representa al objeto receptor del mensaje, y Python lo pasarÃ¡ automÃ¡ticamente siempre que enviemos uno.

Por ejemplo cuando hagamos...

>> pepita.comer_alipste(10)
... Python pasarÃ¡ automÃ¡ticamente a pepita a travÃ©s del parÃ¡metro self. Y si hacemos...

>> anastasia.comer_alipste(10)
AquÃ­ self representarÃ¡ a anastasia. Esto nos permite que definamos mÃ©todos que accedan al estado del objeto que estÃ¡ recibiendo el mensaje (como en .comer_alpiste) o que le enviemos mÃ¡s mensajes (como en volar_en_circulos, que envÃ­a a self el mensaje volar).

Un poco de prÃ¡ctica
ğŸ§—ğŸ»â€â™€ï¸ Desafio I: Ahora te toca a vos:

CreÃ¡ a la golondrina maria con 42 puntos de energÃ­a inicial
CreÃ¡ al dragÃ³n chimuelo, con 200 dientes y 1000 de energÃ­a inicial
DefinÃ­ el mÃ©todo esta_debil, que nos dice si nuestras "aves" tiene menos de 10 puntos de energÃ­a (golondrinas) o menos de 50 puntos de energÃ­a (dragones)
DefinÃ­ el mÃ©todo esta_feliz, que nos dice si nuestras "aves" tiene mÃ¡s de 500 puntos de energÃ­a (sin importar de quÃ© clase sean)
Hace a hipo, entrenador de dragones: sabe aceptar a dragones, quienes son sus entrenados y hacerlos entrenar todos los dias, haciendoles dar 20 vueltas en circulos y luego comer su comida favorita hasta saciarse (3 peces)
HacÃ© que hipo pueda entrenar a las golondrinas. Â¿QuÃ© comportamiento deberÃ­an entender las golondrinas ahora?
DefinÃ­ el mÃ©todo entrenamiento_intensivo, que hace dar vueltas en circulos a sus entrenados hasta que estÃ©n dÃ©biles.
9. Herencia

Â¿Ves algo repetido entre las golondrinas y los dragones? SÃ­, Â¡el mÃ©todo estÃ¡_feliz! Extraigamos la lÃ³gica comÃºn a una clase AnimalAlado.

class AnimalAlado:
  def esta_feliz(self):
    return self.energia >= 500

class Golondrina(AnimalAlado):

  ... etc ...

class Dragon(AnimalAlado):

  ... etc ...
Diremos ademÃ¡s que esta clase es una clase abstracta, porque no existe para tener instancias directas.

ğŸ’¡ FormalizaciÃ³n: La herencia es un proceso mediante el cual se puede crear una clase hija que hereda de una clase madre sus mÃ©todos y atributos.

ğŸ§—ğŸ»â€â™€ï¸ Desafio II:

Ahora hacÃ© las modificaciones en las clases Golondrina y Dragones para que un Entrenador pueda entrenar tanto a aves como dragones.
CreÃ¡ una clase de AvesNoVoladoras, que come_alpiste y como su nombre indica no puede volar_en_circulos pero si correr_en_circulos disminuyendo su energÃ­a en 25.
Â¿Las AvesNoVoladoras son polimÃ³rficas con las aves Golondrinas desde el punto de vista del Entrenedor?Â¿CÃ³mo podemos solucionar este inconveniente?
