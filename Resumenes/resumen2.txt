EJEMPLO:

Problema: ü•ü Preparar Empanadas
  Paradigma De Cocinar en Casa (PCC)
    Necesitamos:
      - ingredientes
      - horno
      - tiempo
      - conocimiento (receta)
      - heladera: guardar ingredientes

  Paradigma de Pedir Afuera (PPA)
    Necesitamos:
      - plata
      - aplicacion / telefono
      - heladera: repositorio de imanes/telefono
    Ventaja:
      - mas facil
    Desventaja:
      - Tenemos menos control


OTRO EJEMPLO:
Problema: üñ•Ô∏è Programar
  Paradigma Imperativo/Procedural
    Necesitamos:
      ifs
      procedimientos
      funciones
      variables

  Paradigma Orientado a Objetos:
    Necesitamos:
      if
      variable

Objetos y mensajes
Somos ornit√≥logos y ornit√≥logas que estudiamos el comportamiento de las aves, y Pepita es una golondrina.

from aves import pepita
¬øQu√© sabe hacer pepita? ¬øSabe volar_en_circulos?

>> pepita.volar_en_circulos()
¬øSabe cantar_boleros?

>> pepita.cantar_boleros()
# AttributeError: 'Golondrina' object has no attribute 'cantar_boleros'
Ups, no üòõ. ¬øY sabe comer_alpiste?

>> pepita.comer_alpiste()
# TypeError: comer_alpiste() missing 1 required positional argument: 'gramos'
Ups, s√≠, pero tenemos que decirle cuantos gramos de alpiste queremos que coma

>> pepita.comer_alpiste(10)
üí°Formalizaci√≥n: pepita es un objeto, y como todo objeto, entiende algunos mensajes. En particular, nuestra golondrina entiende los mensajes comer_alpiste y volar_en_circulos, pero no entiende cantar_boleros (ni casi ninguna otra cosa que se te ocurra :wink:) En otras palabras, pepita sabe comer alpiste y volar en circulos.

Por otro lado, si le pedimos a un objeto que haga cosas que no sabe hacer, √©ste se rehusar√°.

¬øY qu√© pasa cuando le enviamos estos mensajes? pepita no tiene infinita energ√≠a para hacer todo lo que le pidamos, sino que sabe cuanta es la energia que le queda:

>> pepita.energia
üéØ Sabiendo esto, ¬øte anim√°s a averiguar c√≥mo queda la energia despu√©s de hacerla comer alpiste? ¬øy despu√©s de hacerla volar en c√≠rculos?

Como vemos, cada vez que hacemos que pepita coma y vuele, su energia cambia.

üí° Formalizaci√≥n: los objetos pueden tener estado (en el caso de pepita, su estado es la energ√≠a), el cual puede cambiar a lo largo del tiempo.

üéØ ¬øTe anim√°s a averiguar seg√∫n qu√© formula?

üí° Formalizaci√≥n: cada vez que un objeto recibe un mensaje, hace algo, reaccionando al mismo. Por tanto, decimos que los objetos tienen un cierto comportamiento (por ejemplo, cuando pepita come alpiste, su energia sube en tantas unidades como los gramos ingeridos)

Ambiente e interfaces
pepita no es nuestra √∫nica golondrina. Tambi√©n contamos con anastasia:

>> pepita == anastasia
False
Como vemos, aunque las dos son golondrinas, no son el mismo objeto, y por eso si las comparamos con == nos dar√° False. De hecho, un objeto s√≥lo es id√©ntico a s√≠ mismo.

>> pepita == pepita
True
üí° Formalizaci√≥n: la identidad es la propiedad por la que los objetos ‚Äúsaben‚Äù que son diferentes a los dem√°s.

¬øY que hay de su energ√≠a? ¬øTendr√° lan misma?

>> pepita.energia
100
>> anastasia.energia
200
anastasia es otro objeto, y como tal, cuenta con su propio estado. Por eso es que si bien las dos tienen energia, presentan valores diferentes. ¬øQu√© cosas sabr√° hacer anastasia?

>> anastasia.volar_en_circulos()
>> anastasia.comer_alpiste(10)
Como anastasia es otra golondrina, sabe hacer las mismas cosas que pepita.

üí° Formalizaci√≥n: llamaremos ambiente al contexto en el que el viven los objetos, tienen su estado y pueden entender mensajes. En un mismo ambiente podemos contar con varios objetos, como por ejemplo, pepita y anastasia.

En otras palabras es el mundo que los objetos habitan üåé y en que se relacionan . Cada vez que apretamos play en replit, o le damos reset en colab, o cerramos nuestro int√©rprete de python en nuestra computadora y lo volvemos a iniciar, estamos destruyendo ese mundo y volviendo a empezar.

Pero no s√≥lo contamos con pepita y anastasia, sino tambi√©n con roberta. ¬øCu√°nta energ√≠a tendr√° inicialmente?

>> roberta.energia
üòÆ Ohh, ¬°tiene mucha energia! Y tambi√©n sabr√° volar en c√≠rculos, ¬øno?

>> roberta.volar_en_circulos()
>> roberta.energia
Bien, aunque como vemos perdi√≥ s√≥lo una unidad de energ√≠a, pese a que anastasia y pepita gastan 10 al hacerlo. Parece que las tres saben hacer lo mismo, pero roberta lo hace de forma diferente.

üí° Formalizaci√≥n: no todos los objetos tienen que reaccionar de igual forma a los mismos mensajes. En otras palabras, no todos los objetos tienen por qu√© comportarse igual.

¬øY qu√© hay sobre comer_alpiste?

>> roberta.comer_alpiste(10)
Ey, ¬°no le gusta el alpiste! Pero nos dijeron que s√≠ le gusta comer peces:

>> roberta.comer_peces(2)
>> roberta.energia
üí° Formalizaci√≥n: no todos los objetos tienen qu√© entender los mismos mensajes. Por ejemplo roberta no entiende comer_alpiste, pero s√≠ entiende comer_peces (que anastasia y pepita no entienden, si no nos cre√©s pod√©s comprobarlo vos :smile:). Al conjunto de mensajes que cada objeto expone lo llamaremos interfaz, la cual puede ser (y t√≠picamente ser√°) diferente para cada objeto.

Qu√© rara es nuestra nueva golondrina, ¬øno? ¬°Es que no es una Golondrina! ¬°Es un drag√≥n! üî•

>> roberta.escupir_fuego()
Perd√≥n, esperamos no haber quemado nada üôà

Interfaces compartidas
Entonces, ¬øpepita y roberta se comportan igual? ¬°No! ¬øY tienen la misma interfaz? ¬°Tampoco! Pero s√≠ tienen una parte com√∫n; en otras palabras comparten (parcialmente) una interfaz:

 	üåæ comer_alpiste	üêü comer_peces	üî• escupir_fuego	‚úàÔ∏è volar	üîÑ volar_en_circulos
pepita	‚úÖÔ∏è	 	 	‚úÖÔ∏è	‚úÖÔ∏è
anastasia	‚úÖÔ∏è	 	 	‚úÖÔ∏è	‚úÖÔ∏è
roberta	 	‚úÖÔ∏è	‚úÖÔ∏è	‚úÖÔ∏è	‚úÖÔ∏è
Clases
Momento, ¬øy c√≥mo est√°n definidas pepita, anastasia y roberta? ¬øD√≥nde dice qu√© saber hacer cada una y c√≥mo?

En el paradigma de objetos, los mismos se crean a partir de moldes llamados clases, que sirven para dar vida a objetos que se comporten de igual forma. Por ejemplo nuestras golondrinas pepita y anastasia se crear√°n de la siguiente forma‚Ä¶.

pepita = Golondrina(100)
anastasia = Golondrina(200)
‚Ä¶ partir de una clase llamada Golondrina que se ver√° as√≠:

class Golondrina:
  def __init__(self, energia):
    self.energia = energia

  def comer_alpiste(self, gramos):
    self.energia += 4 * gramos

  def volar_en_circulos(self):
    self.volar(0)

  def volar(self, kms):
    self.energia -= 10 + kms
üí° Formalizaci√≥n: al acto de crear un objeto a partir de una clase se lo denomina instanciaci√≥n, y por tanto a los objetos tambi√©n se los denomina instancias (de una clase particular). Por ejemplo, pepita es una instancia (de la clase Golondrina).

Si bien el t√©rmino instancia quiz√°s no nos diga mucho, en este contexto significa ‚Äúejemplo‚Äù, dado que cada golondrina como pepita o anastasia son ejemplo concretos (es decir, casos particulares) de la idea m√°s general de una Golondrina.

Como vemos, una clase es nuevo tipo de definici√≥n, que se suma a las funciones y procedimientos que ya conoc√≠amos. Se escribe mediante la palabra reservada class, seguida de un nombre y :. Dentro de ella encontraremos los m√©todos, que son el c√≥digo que especifica c√≥mo se comportar√° un objeto cuando reciba un mensaje.

üìù Nota: s√≠, los m√©todos se definen usando la misma palabra clave def que usabamos para funciones y procedimientos. Sin embargo, no son lo mismo: como podemos ver los m√©todos siempre est√°n ‚Äúdentro‚Äù de una clase, y adem√°s tienen como primer par√°metro self. M√°s sobre esto, en breve.

Parecidos pero distintos: m√©todos vs funciones
Tomemos este m√©todo como ejemplo:

class Golondrina:
  def comer_alpiste(self, gramos):
    self.energia = self.energia + 4 * gramos
üëÄ Ojo, porque los m√©todos y las funciones, si bien se ven parecidos, no son lo mismo.

Las funciones se invocan como funcion(argumentos), pero los m√©todos se evaluan a trav√©s el envio de mensajes como objeto.mensaje(argumentos)
los m√©todos tienen siempre declaran como primer par√°metro self, las funciones no
los m√©todos siempre van dentro de un class, mientras que las funciones van por fuera
¬øQuien soy yo?
Habr√°n notado que una diferencia importante entre una funci√≥n y un m√©todo es el par√°metro self (en ingl√©s, si mismo) que reciben todos los m√©todos en su definici√≥n. Este par√°metro representa al objeto receptor del mensaje, y Python lo pasar√° autom√°ticamente siempre que enviemos uno.

Por ejemplo cuando hagamos‚Ä¶

>> pepita.comer_alipste(10)
‚Ä¶ Python pasar√° autom√°ticamente a pepita a trav√©s del par√°metro self. Y si hacemos‚Ä¶

>> anastasia.comer_alipste(10)
‚Ä¶ self representar√° a anastasia. Esto nos permite que definamos m√©todos que accedan al estado del objeto que est√° recibiendo el mensaje (como en comer_alpiste) o que le enviemos m√°s mensajes (como en volar_en_circulos, que env√≠a a self el mensaje volar).

Un poco de pr√°ctica
Ahora te toca a vos:

Cre√° a la golondrina maria con 42 puntos de energ√≠a inicial
Cre√° al drag√≥n chimuelo, con 200 dientes y 1000 de energ√≠a inicial
Defin√≠ el m√©todo esta_debil, que nos dice si nuestras ‚Äúaves‚Äù tiene menos de 10 puntos de energia (golondrinas) o menos de 50 puntos de energ√≠a (dragones)
Defin√≠ el m√©todo esta_feliz, que nos dice si nuestras ‚Äúaves‚Äù tiene m√°s de 500 puntos de eneria (sin importar de qu√© clase sean)
Hace a hipo, entrenador de dragones: sabe aceptar a dragones, quienes son sus entrenados y hacerlos entrenar todos los dias, haciendoles dar 20 vueltas en circulos y luego comer su comida favorita hasta saciarse (3 peces)
Hac√© que hipo pueda entrenar a las golondrinas. ¬øQu√© comportamiento deber√≠an entender las golondrinas ahora?
Defin√≠ el m[etodo entrenamiento_intensivo, que hace dar vultas en circulos a sus entrenados hasta que est√©n d√©biles.
Constructores
Hacemos un alto en el camino para entender los constructores. Como habr√°s notado, nuestras clases tienen un m√©todo ‚Äúraro‚Äù, que se llama __init__:

class Golondrina:
  def __init__(self, energia):
    self.energia = energia
Este m√©todo no tiene ese nombre ex√≥tico porque s√≠: se trata de uno muy especial, que, siempre que est√© definido, Python ejecutar√° justo cuando instanciemos un objeto de la clase correspondiente. Este m√©todo puede tomar cualquier cantidad de par√°metros, los cuales se corresponder√°n con la cantidad de argumentos que tenemos que pasar al momento de crear a nuestro objeto.

Este m√©todo especial, llamado constructor, se usa t√≠picamente para darle valores iniciales a los atributos del objeto, ya sean predefinido o dependientes de lo que se pase como argumento.

Herencia
¬øVes algo repetido entre las golondrinas y los dragones? S√≠, ¬°el m√©todo est√°_feliz! Extraigamos la l√≥gica com√∫n a una clase AnimalAlado.

class AnimalAlado:
  def esta_feliz(self):
    return self.energia >= 500

class Golondrina(AnimalAlado):

  ... etc ...

class Dragon(AnimalAlado):

  ... etc ...
Diremos adem√°s que esta clase es una clase abstracta, porque no existe para tener instancias directas.

Por panamericana
Ah, pero no tan r√°pido. Ahora te toca a vos: implement√° el m√©todo volar_por_panamericana que nos permite decirle a un animal alado que vuele hasta un cierto lugar a lo largo de ciudades de la Ruta Panamericana. Ten√© en cuenta algunos puntos notables de la ruta:

Ushuaia es el km 0
Buenos Aires es el km 3078
Valparaiso (Chile) es el km 4533
Bah√≠a Prudhoe (Alaska) es el km 17958.
Para pensar: ¬øtiene algo raro este nuevo m√©todo?

Afloj√° con el aparatito
¬°Integremos lo visto con otra situaci√≥n!

Es innegable que en la actualidad los dispositivos electr√≥nicos atraviesan nuestro d√≠a a d√≠a :electric_plug:. Desde celulares :iphone: hasta notebooks:computer: que est√°n presentes tanto en nuestro ocio como en nuestros trabajos o estudios. Es por eso que vamos a modelar distintos dispositivos utilizando la programaci√≥n con objetos.

Para entrar en calor vamos a modelar la clase Celular, ¬øqu√© sabemos de ellos?

Todos los celulares tienen su bateria en 100 inicialmente;
Cuando utilizamos un Celular, su bater√≠a disminuye en la mitad de los minutos que lo hagamos. Por ejemplo: si usamos el celular 30 minutos, su bater√≠a bajar√° en 15.
Los celulares se pueden cargar_a_tope para dejar la bater√≠a en 100.
Defin√≠ la clase Celular y tambi√©n los m√©todos __init__, utilizar y cargar_a_tope. No nos vamos a preocupar por ahora en que tenga suficiente bateria para poder utilizarlo. :wink:

¬°Ahora es el turno de la Notebook! :computer:

La clase Notebook entiende los mismos mensajes que Celular y se comporta parecido pero no exactamente igual. La diferencia est√° en que a la hora de utilizar una notebook, su bateria disminuye en la cantidad de minutos que la utilicemos.

Defin√≠ la clase Notebook, que sepa entender los mensajes __init__, utilizar y cargar_a_tope.

S√≠, definitivamente Celular y Notebook tienen comportamiento repetido. :face_with_raised_eyebrow:

Para pensar: ¬øqu√© m√©todos son iguales en ambas clases?

Con esto en cuenta, defin√≠ una clase abstracta com√∫n y modific√° las clases que definiste anteriormente para evitar que haya m√©todos repetidos entre Celular y Notebook. ¬øComo la llamar√≠as?

Una de las grandes molestias que nos traen los dispositivos electr√≥nicos es cuando se quedan sin bater√≠a. :battery: Sabemos que tanto los celulares como las notebooks est√°n descargados si tienen 20 o menos de bater√≠a. :electric_plug:

Defin√≠ el m√©todo descargado en donde corresponda.

¬øFunciona todo esto que estuvimos haciendo?

Prob√° en la consola los siguientes comandos:

un_celu = Celular()
una_notebook = Notebook()
un_celu.descargado()
un_celu.utilizar(180)
un_celu.descargado()
una_notebook.utilizar(100)
una_notebook.cargar_a_tope()
una_notebook.descargado()
Ah, pero nos estabamos olvidando de algo fundamental: Lu usa todos los d√≠as todos sus dispositivos (con tanta virtualidad no podr√≠a ser de otra forma) y necesita recargarlos en su mesita de luz antes de irse a dormir.

Model√° esta situaci√≥n, para Lu (o cualquier otra persona due√±a de aparatitos electr√≥nicos) pueda cargar a tope todos sus dispositivos en un solo comando.


Delegaci√≥n y Polimorfismo
Sueldo de Pepe
Ejercicio basado en El sueldo de Pepe

Desarrollar los objetos necesarios para calcular el sueldo de Pepe. El sueldo de pepe se calcula as√≠:

sueldo = sueldo base + bono x presentismo + bono x resultados.
El sueldo base es el de la categor√≠a, hay dos categor√≠as:

gerentes que ganan $1000 de sueldo base,
cadetes que ganan $1500.
Hay dos bonos por presentismo:

Es $100 si la persona a quien se aplica no falt√≥ nunca, $50 si falt√≥ un d√≠a, $0 en cualquier otro caso;
En el otro, nada.
Hay tres posibilidades para el bono por resultados:

Un porcentaje sobre el sueldo base
Un valor fijo
O nada
Probar cambi√°ndole a pepe la categor√≠a, la cantidad de d√≠as que falta y haciendo que cumpla sus objetivos. Probar tambi√©n cambiar sus bonos por presentismo y por resultados, o con nosotros empelados con diferente categor√≠a y bonos. En cada caso preguntarle su sueldo.

>>>
>>> dani.faltar()
>>> dani.faltas
1
>>> dani.sueldo_total()
1050
>>> dani.faltar()
>>> dani.faltar()
>>> dani.faltar()
>>> dani.sueldo_total()
1000
>>>
>>> umi.sueldo_total()
1500
>>> umi.cumplir_objetivos()
>>> umi.sueldo_total()
1725.0
>>> umi.bono_resultados = BonoFijoPorResultados(80)
>>> umi.sueldo_total()
1580
>>>
Trenes y dep√≥sitos
Una administradora ferroviaria necesita una aplicacioÃÅn que le ayude a manejar las formaciones que tiene disponibles en distintos depoÃÅsitos. Una formacioÃÅn es lo que habitualmente llamamos ‚Äúun tren‚Äù, tiene una o varias locomotoras, y uno o varios vagones. Hay vagones de pasajeros y vagones de carga. En cada depoÃÅsito hay: formaciones ya armadas, y locomotoras sueltas que pueden ser agregadas a una formacioÃÅn.

De cada vagoÃÅn de pasajeros se conoce el largo en metros, y el ancho uÃÅtil tambieÃÅn en metros. La cantidad de pasajeros que puede transportar un vagoÃÅn de pasajeros es: Si el ancho uÃÅtil es de hasta 2.5 metros: metros de largo * 8. Si el ancho uÃÅtil es de maÃÅs de 2.5 metros: metros de largo * 10. P.ej., si tenemos dos vagones de pasajeros, los dos de 10 metros de largo, uno de 2 metros de ancho uÃÅtil, y otro de 3 metros de ancho uÃÅtil, entonces el primero puede llevar 80 pasajeros, y el segundo puede llevar 100. Un vagoÃÅn de pasajeros no puede llevar carga.

De cada vagoÃÅn de carga se conoce la carga maÃÅxima que puede llevar, en kilos. Un vagoÃÅn de carga no puede llevar ninguÃÅn pasajero. No hay vagones mixtos.

El peso maÃÅximo de un vagoÃÅn, medido en kilos, se calcula asiÃÅ: Para un vagoÃÅn de pasajeros: cantidad de pasajeros que puede llevar * 80. Para un vagoÃÅn de carga: la carga maÃÅxima que puede llevar + 160 (en cada vagoÃÅn de carga van dos guardas).

De cada locomotora se sabe: su peso, el peso maÃÅximo que puede arrastrar, y su velocidad maÃÅxima. P.ej. puedo tener una locomotora que pesa 1000 kg, puede arrastrar hasta 12000 kg, y su velocidad maÃÅxima es de 80 km/h. Obviamente se tiene que arrastrar a ella misma, entonces no le puedo cargar 12000 kg de vagones, solamente 11000; diremos que este es su ‚Äúarrastre uÃÅtil‚Äù.

Modelar la situacioÃÅn descripta de acuerdo al paradigma de objetos, escribiendo el coÃÅdigo en lenguaje Wollok, de manera de poder saber: El total de pasajeros que puede transportar una formacioÃÅn. CuaÃÅntos vagones livianos tiene una formacioÃÅn; un vagoÃÅn es liviano si su peso maÃÅximo es menor a 2500 kg. La velocidad maÃÅxima de una formacioÃÅn, que es el miÃÅnimo entre las velocidades maÃÅximas de las locomotoras. Si una formacioÃÅn es eficiente; es eficiente si cada una de sus locomotoras arrastra, al menos, 5 veces su peso (el de la locomotora misma). Si una formacioÃÅn puede moverse. Una formacioÃÅn puede moverse si el arrastre uÃÅtil total de las locomotoras es mayor o igual al peso maÃÅximo total de los vagones. CuaÃÅntos kilos de empuje le faltan a una formacioÃÅn para poder moverse, que es: 0 si ya se puede mover, y (peso maÃÅximo total de los vagones ‚Äì arrastre uÃÅtil total de las locomotoras) en caso contrario. Dado un depoÃÅsito, el conjunto formado por el vagoÃÅn maÃÅs pesado de cada formacioÃÅn; se espera un conjunto de vagones. Si un depoÃÅsito necesita un conductor experimentado. Un depoÃÅsito necesita un conductor experimentado si alguna de sus formaciones es compleja. Una formacioÃÅn es compleja si: tiene maÃÅs de 20 unidades (sumando locomotoras y vagones), o el peso total (sumando locomotoras y vagones) es de maÃÅs de 10000 kg. Agregar, dentro de un depoÃÅsito, una locomotora a una formacioÃÅn determinada, de forma tal que la formacioÃÅn pueda moverse. Si la formacioÃÅn ya puede moverse, entonces no se hace nada. Si no, se le agrega una locomotora suelta del depoÃÅsito cuyo arrastre uÃÅtil sea mayor o igual a los kilos de empuje que le faltan a la formacioÃÅn. Si no hay ninguna locomotora suelta que cumpla esta condicioÃÅn, no se hace nada.

O sea: indicar queÃÅ clases se necesitan, queÃÅ variables de instancia se necesitan en cada clase, queÃÅ mensajes van a entender las instancias de cada clase, y escribir los meÃÅtodos correspondientes. Para cada punto, indicar a queÃÅ objeto se le pide lo que se indica, con queÃÅ mensaje, queÃÅ paraÃÅmetros, y queÃÅ devuelve. Para el punto 8, indicar en queÃÅ otros objetos delega el responsable de hacer lo que se pide, y queÃÅ delega (indicar lo que se delega en castellano). Si hay una cadena de delegaciones (al objeto 1 le piden algo, entonces delega algo en el objeto 2, y el objeto 2 para hacer lo que le pidioÃÅ el 1 tiene que delegar otra cosa en otro objeto 3) indicarla.

Ejercicio 2 ‚Äì Mascota Virtual Modelar una mascota virtual, onda Tamagotchi, incluyendo los mensajes correspondientes a las acciones de comer y jugar, y la pregunta acerca de si puede jugar o no.

TambieÃÅn hay que poder conocer el nivel de contenta de una mascota, que es un nuÃÅmero entero mayor o igual que 0, donde a mayor nivel, maÃÅs contenta estaÃÅ la mascota.

Una mascota puede estar aburrida, hambrienta o contenta; y su comportamiento depende de en queÃÅ estado esteÃÅ. Veamos:

Cuando una mascota come, pasa lo siguiente: Si estaÃÅ hambrienta, se pone contenta. Si estaÃÅ contenta, su nivel se incrementa en una unidad. Si estaÃÅ aburrida, y hace maÃÅs de 80 minutos que estaÃÅ aburrida, entonces se pone contenta. Si estaÃÅ aburrida desde hace 80 minutos o menos, entonces no le pasa nada, no cambia nada.

Cuando una mascota juega, pasa lo siguiente: Si estaÃÅ contenta, su nivel se incrementa en dos unidades. Si estaÃÅ aburrida, se pone contenta. No produce ninguÃÅn efecto jugar con la mascota si est√° hambrienta.

Una mascota puede jugar si estaÃÅ contenta o aburrida, si estaÃÅ hambrienta no.

NO SE PUEDE CONSULTAR DE NINGUNA MANERA EL ESTADO ACTUAL DE LA MASCOTA. Esto quiere decir que estaÃÅ prohibido hacer comparaciones del tipo estado == ‚Äúcontento‚Äù o cualquiera similar utilizando mensajes especiales.

Responder las siguientes preguntas: Indique en palabras los pasos necesarios para incorporar un nuevo estado ‚ÄúTriste‚Äù en la mascota, de manera que quede listo para funcionar. Indique cuaÃÅl seriÃÅa la prueba en un test similar para darles de comer a todas las mascotas que estaÃÅn dentro de una coleccioÃÅn ‚Äúmascotas‚Äù.