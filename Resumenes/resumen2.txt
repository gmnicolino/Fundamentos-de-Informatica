EJEMPLO:

Problema: ğŸ¥Ÿ Preparar Empanadas
  Paradigma De Cocinar en Casa (PCC)
    Necesitamos:
      - ingredientes
      - horno
      - tiempo
      - conocimiento (receta)
      - heladera: guardar ingredientes

  Paradigma de Pedir Afuera (PPA)
    Necesitamos:
      - plata
      - aplicacion / telefono
      - heladera: repositorio de imanes/telefono
    Ventaja:
      - mas facil
    Desventaja:
      - Tenemos menos control


OTRO EJEMPLO:
Problema: ğŸ–¥ï¸ Programar
  Paradigma Imperativo/Procedural
    Necesitamos:
      ifs
      procedimientos
      funciones
      variables

  Paradigma Orientado a Objetos:
    Necesitamos:
      if
      variable

Objetos y mensajes
Somos ornitÃ³logos y ornitÃ³logas que estudiamos el comportamiento de las aves, y Pepita es una golondrina.

from aves import pepita
Â¿QuÃ© sabe hacer pepita? Â¿Sabe volar_en_circulos?

>> pepita.volar_en_circulos()
Â¿Sabe cantar_boleros?

>> pepita.cantar_boleros()
# AttributeError: 'Golondrina' object has no attribute 'cantar_boleros'
Ups, no ğŸ˜›. Â¿Y sabe comer_alpiste?

>> pepita.comer_alpiste()
# TypeError: comer_alpiste() missing 1 required positional argument: 'gramos'
Ups, sÃ­, pero tenemos que decirle cuantos gramos de alpiste queremos que coma

>> pepita.comer_alpiste(10)
ğŸ’¡FormalizaciÃ³n: pepita es un objeto, y como todo objeto, entiende algunos mensajes. En particular, nuestra golondrina entiende los mensajes comer_alpiste y volar_en_circulos, pero no entiende cantar_boleros (ni casi ninguna otra cosa que se te ocurra :wink:) En otras palabras, pepita sabe comer alpiste y volar en circulos.

Por otro lado, si le pedimos a un objeto que haga cosas que no sabe hacer, Ã©ste se rehusarÃ¡.

Â¿Y quÃ© pasa cuando le enviamos estos mensajes? pepita no tiene infinita energÃ­a para hacer todo lo que le pidamos, sino que sabe cuanta es la energia que le queda:

>> pepita.energia
ğŸ¯ Sabiendo esto, Â¿te animÃ¡s a averiguar cÃ³mo queda la energia despuÃ©s de hacerla comer alpiste? Â¿y despuÃ©s de hacerla volar en cÃ­rculos?

Como vemos, cada vez que hacemos que pepita coma y vuele, su energia cambia.

ğŸ’¡ FormalizaciÃ³n: los objetos pueden tener estado (en el caso de pepita, su estado es la energÃ­a), el cual puede cambiar a lo largo del tiempo.

ğŸ¯ Â¿Te animÃ¡s a averiguar segÃºn quÃ© formula?

ğŸ’¡ FormalizaciÃ³n: cada vez que un objeto recibe un mensaje, hace algo, reaccionando al mismo. Por tanto, decimos que los objetos tienen un cierto comportamiento (por ejemplo, cuando pepita come alpiste, su energia sube en tantas unidades como los gramos ingeridos)

Ambiente e interfaces
pepita no es nuestra Ãºnica golondrina. TambiÃ©n contamos con anastasia:

>> pepita == anastasia
False
Como vemos, aunque las dos son golondrinas, no son el mismo objeto, y por eso si las comparamos con == nos darÃ¡ False. De hecho, un objeto sÃ³lo es idÃ©ntico a sÃ­ mismo.

>> pepita == pepita
True
ğŸ’¡ FormalizaciÃ³n: la identidad es la propiedad por la que los objetos â€œsabenâ€ que son diferentes a los demÃ¡s.

Â¿Y que hay de su energÃ­a? Â¿TendrÃ¡ lan misma?

>> pepita.energia
100
>> anastasia.energia
200
anastasia es otro objeto, y como tal, cuenta con su propio estado. Por eso es que si bien las dos tienen energia, presentan valores diferentes. Â¿QuÃ© cosas sabrÃ¡ hacer anastasia?

>> anastasia.volar_en_circulos()
>> anastasia.comer_alpiste(10)
Como anastasia es otra golondrina, sabe hacer las mismas cosas que pepita.

ğŸ’¡ FormalizaciÃ³n: llamaremos ambiente al contexto en el que el viven los objetos, tienen su estado y pueden entender mensajes. En un mismo ambiente podemos contar con varios objetos, como por ejemplo, pepita y anastasia.

En otras palabras es el mundo que los objetos habitan ğŸŒ y en que se relacionan . Cada vez que apretamos play en replit, o le damos reset en colab, o cerramos nuestro intÃ©rprete de python en nuestra computadora y lo volvemos a iniciar, estamos destruyendo ese mundo y volviendo a empezar.

Pero no sÃ³lo contamos con pepita y anastasia, sino tambiÃ©n con roberta. Â¿CuÃ¡nta energÃ­a tendrÃ¡ inicialmente?

>> roberta.energia
ğŸ˜® Ohh, Â¡tiene mucha energia! Y tambiÃ©n sabrÃ¡ volar en cÃ­rculos, Â¿no?

>> roberta.volar_en_circulos()
>> roberta.energia
Bien, aunque como vemos perdiÃ³ sÃ³lo una unidad de energÃ­a, pese a que anastasia y pepita gastan 10 al hacerlo. Parece que las tres saben hacer lo mismo, pero roberta lo hace de forma diferente.

ğŸ’¡ FormalizaciÃ³n: no todos los objetos tienen que reaccionar de igual forma a los mismos mensajes. En otras palabras, no todos los objetos tienen por quÃ© comportarse igual.

Â¿Y quÃ© hay sobre comer_alpiste?

>> roberta.comer_alpiste(10)
Ey, Â¡no le gusta el alpiste! Pero nos dijeron que sÃ­ le gusta comer peces:

>> roberta.comer_peces(2)
>> roberta.energia
ğŸ’¡ FormalizaciÃ³n: no todos los objetos tienen quÃ© entender los mismos mensajes. Por ejemplo roberta no entiende comer_alpiste, pero sÃ­ entiende comer_peces (que anastasia y pepita no entienden, si no nos creÃ©s podÃ©s comprobarlo vos :smile:). Al conjunto de mensajes que cada objeto expone lo llamaremos interfaz, la cual puede ser (y tÃ­picamente serÃ¡) diferente para cada objeto.

QuÃ© rara es nuestra nueva golondrina, Â¿no? Â¡Es que no es una Golondrina! Â¡Es un dragÃ³n! ğŸ”¥

>> roberta.escupir_fuego()
PerdÃ³n, esperamos no haber quemado nada ğŸ™ˆ

Interfaces compartidas
Entonces, Â¿pepita y roberta se comportan igual? Â¡No! Â¿Y tienen la misma interfaz? Â¡Tampoco! Pero sÃ­ tienen una parte comÃºn; en otras palabras comparten (parcialmente) una interfaz:

 	ğŸŒ¾ comer_alpiste	ğŸŸ comer_peces	ğŸ”¥ escupir_fuego	âœˆï¸ volar	ğŸ”„ volar_en_circulos
pepita	âœ…ï¸	 	 	âœ…ï¸	âœ…ï¸
anastasia	âœ…ï¸	 	 	âœ…ï¸	âœ…ï¸
roberta	 	âœ…ï¸	âœ…ï¸	âœ…ï¸	âœ…ï¸
Clases
Momento, Â¿y cÃ³mo estÃ¡n definidas pepita, anastasia y roberta? Â¿DÃ³nde dice quÃ© saber hacer cada una y cÃ³mo?

En el paradigma de objetos, los mismos se crean a partir de moldes llamados clases, que sirven para dar vida a objetos que se comporten de igual forma. Por ejemplo nuestras golondrinas pepita y anastasia se crearÃ¡n de la siguiente formaâ€¦.

pepita = Golondrina(100)
anastasia = Golondrina(200)
â€¦ partir de una clase llamada Golondrina que se verÃ¡ asÃ­:

class Golondrina:
  def __init__(self, energia):
    self.energia = energia

  def comer_alpiste(self, gramos):
    self.energia += 4 * gramos

  def volar_en_circulos(self):
    self.volar(0)

  def volar(self, kms):
    self.energia -= 10 + kms
ğŸ’¡ FormalizaciÃ³n: al acto de crear un objeto a partir de una clase se lo denomina instanciaciÃ³n, y por tanto a los objetos tambiÃ©n se los denomina instancias (de una clase particular). Por ejemplo, pepita es una instancia (de la clase Golondrina).

Si bien el tÃ©rmino instancia quizÃ¡s no nos diga mucho, en este contexto significa â€œejemploâ€, dado que cada golondrina como pepita o anastasia son ejemplo concretos (es decir, casos particulares) de la idea mÃ¡s general de una Golondrina.

Como vemos, una clase es nuevo tipo de definiciÃ³n, que se suma a las funciones y procedimientos que ya conocÃ­amos. Se escribe mediante la palabra reservada class, seguida de un nombre y :. Dentro de ella encontraremos los mÃ©todos, que son el cÃ³digo que especifica cÃ³mo se comportarÃ¡ un objeto cuando reciba un mensaje.

ğŸ“ Nota: sÃ­, los mÃ©todos se definen usando la misma palabra clave def que usabamos para funciones y procedimientos. Sin embargo, no son lo mismo: como podemos ver los mÃ©todos siempre estÃ¡n â€œdentroâ€ de una clase, y ademÃ¡s tienen como primer parÃ¡metro self. MÃ¡s sobre esto, en breve.

Parecidos pero distintos: mÃ©todos vs funciones
Tomemos este mÃ©todo como ejemplo:

class Golondrina:
  def comer_alpiste(self, gramos):
    self.energia = self.energia + 4 * gramos
ğŸ‘€ Ojo, porque los mÃ©todos y las funciones, si bien se ven parecidos, no son lo mismo.

Las funciones se invocan como funcion(argumentos), pero los mÃ©todos se evaluan a travÃ©s el envio de mensajes como objeto.mensaje(argumentos)
los mÃ©todos tienen siempre declaran como primer parÃ¡metro self, las funciones no
los mÃ©todos siempre van dentro de un class, mientras que las funciones van por fuera
Â¿Quien soy yo?
HabrÃ¡n notado que una diferencia importante entre una funciÃ³n y un mÃ©todo es el parÃ¡metro self (en inglÃ©s, si mismo) que reciben todos los mÃ©todos en su definiciÃ³n. Este parÃ¡metro representa al objeto receptor del mensaje, y Python lo pasarÃ¡ automÃ¡ticamente siempre que enviemos uno.

Por ejemplo cuando hagamosâ€¦

>> pepita.comer_alipste(10)
â€¦ Python pasarÃ¡ automÃ¡ticamente a pepita a travÃ©s del parÃ¡metro self. Y si hacemosâ€¦

>> anastasia.comer_alipste(10)
â€¦ self representarÃ¡ a anastasia. Esto nos permite que definamos mÃ©todos que accedan al estado del objeto que estÃ¡ recibiendo el mensaje (como en comer_alpiste) o que le enviemos mÃ¡s mensajes (como en volar_en_circulos, que envÃ­a a self el mensaje volar).

Un poco de prÃ¡ctica
Ahora te toca a vos:

CreÃ¡ a la golondrina maria con 42 puntos de energÃ­a inicial
CreÃ¡ al dragÃ³n chimuelo, con 200 dientes y 1000 de energÃ­a inicial
DefinÃ­ el mÃ©todo esta_debil, que nos dice si nuestras â€œavesâ€ tiene menos de 10 puntos de energia (golondrinas) o menos de 50 puntos de energÃ­a (dragones)
DefinÃ­ el mÃ©todo esta_feliz, que nos dice si nuestras â€œavesâ€ tiene mÃ¡s de 500 puntos de eneria (sin importar de quÃ© clase sean)
Hace a hipo, entrenador de dragones: sabe aceptar a dragones, quienes son sus entrenados y hacerlos entrenar todos los dias, haciendoles dar 20 vueltas en circulos y luego comer su comida favorita hasta saciarse (3 peces)
HacÃ© que hipo pueda entrenar a las golondrinas. Â¿QuÃ© comportamiento deberÃ­an entender las golondrinas ahora?
DefinÃ­ el m[etodo entrenamiento_intensivo, que hace dar vultas en circulos a sus entrenados hasta que estÃ©n dÃ©biles.
Constructores
Hacemos un alto en el camino para entender los constructores. Como habrÃ¡s notado, nuestras clases tienen un mÃ©todo â€œraroâ€, que se llama __init__:

class Golondrina:
  def __init__(self, energia):
    self.energia = energia
Este mÃ©todo no tiene ese nombre exÃ³tico porque sÃ­: se trata de uno muy especial, que, siempre que estÃ© definido, Python ejecutarÃ¡ justo cuando instanciemos un objeto de la clase correspondiente. Este mÃ©todo puede tomar cualquier cantidad de parÃ¡metros, los cuales se corresponderÃ¡n con la cantidad de argumentos que tenemos que pasar al momento de crear a nuestro objeto.

Este mÃ©todo especial, llamado constructor, se usa tÃ­picamente para darle valores iniciales a los atributos del objeto, ya sean predefinido o dependientes de lo que se pase como argumento.

Herencia
Â¿Ves algo repetido entre las golondrinas y los dragones? SÃ­, Â¡el mÃ©todo estÃ¡_feliz! Extraigamos la lÃ³gica comÃºn a una clase AnimalAlado.

class AnimalAlado:
  def esta_feliz(self):
    return self.energia >= 500

class Golondrina(AnimalAlado):

  ... etc ...

class Dragon(AnimalAlado):

  ... etc ...
Diremos ademÃ¡s que esta clase es una clase abstracta, porque no existe para tener instancias directas.

Por panamericana
Ah, pero no tan rÃ¡pido. Ahora te toca a vos: implementÃ¡ el mÃ©todo volar_por_panamericana que nos permite decirle a un animal alado que vuele hasta un cierto lugar a lo largo de ciudades de la Ruta Panamericana. TenÃ© en cuenta algunos puntos notables de la ruta:

Ushuaia es el km 0
Buenos Aires es el km 3078
Valparaiso (Chile) es el km 4533
BahÃ­a Prudhoe (Alaska) es el km 17958.
Para pensar: Â¿tiene algo raro este nuevo mÃ©todo?

AflojÃ¡ con el aparatito
Â¡Integremos lo visto con otra situaciÃ³n!

Es innegable que en la actualidad los dispositivos electrÃ³nicos atraviesan nuestro dÃ­a a dÃ­a :electric_plug:. Desde celulares :iphone: hasta notebooks:computer: que estÃ¡n presentes tanto en nuestro ocio como en nuestros trabajos o estudios. Es por eso que vamos a modelar distintos dispositivos utilizando la programaciÃ³n con objetos.

Para entrar en calor vamos a modelar la clase Celular, Â¿quÃ© sabemos de ellos?

Todos los celulares tienen su bateria en 100 inicialmente;
Cuando utilizamos un Celular, su baterÃ­a disminuye en la mitad de los minutos que lo hagamos. Por ejemplo: si usamos el celular 30 minutos, su baterÃ­a bajarÃ¡ en 15.
Los celulares se pueden cargar_a_tope para dejar la baterÃ­a en 100.
DefinÃ­ la clase Celular y tambiÃ©n los mÃ©todos __init__, utilizar y cargar_a_tope. No nos vamos a preocupar por ahora en que tenga suficiente bateria para poder utilizarlo. :wink:

Â¡Ahora es el turno de la Notebook! :computer:

La clase Notebook entiende los mismos mensajes que Celular y se comporta parecido pero no exactamente igual. La diferencia estÃ¡ en que a la hora de utilizar una notebook, su bateria disminuye en la cantidad de minutos que la utilicemos.

DefinÃ­ la clase Notebook, que sepa entender los mensajes __init__, utilizar y cargar_a_tope.

SÃ­, definitivamente Celular y Notebook tienen comportamiento repetido. :face_with_raised_eyebrow:

Para pensar: Â¿quÃ© mÃ©todos son iguales en ambas clases?

Con esto en cuenta, definÃ­ una clase abstracta comÃºn y modificÃ¡ las clases que definiste anteriormente para evitar que haya mÃ©todos repetidos entre Celular y Notebook. Â¿Como la llamarÃ­as?

Una de las grandes molestias que nos traen los dispositivos electrÃ³nicos es cuando se quedan sin baterÃ­a. :battery: Sabemos que tanto los celulares como las notebooks estÃ¡n descargados si tienen 20 o menos de baterÃ­a. :electric_plug:

DefinÃ­ el mÃ©todo descargado en donde corresponda.

Â¿Funciona todo esto que estuvimos haciendo?

ProbÃ¡ en la consola los siguientes comandos:

un_celu = Celular()
una_notebook = Notebook()
un_celu.descargado()
un_celu.utilizar(180)
un_celu.descargado()
una_notebook.utilizar(100)
una_notebook.cargar_a_tope()
una_notebook.descargado()
Ah, pero nos estabamos olvidando de algo fundamental: Lu usa todos los dÃ­as todos sus dispositivos (con tanta virtualidad no podrÃ­a ser de otra forma) y necesita recargarlos en su mesita de luz antes de irse a dormir.

ModelÃ¡ esta situaciÃ³n, para Lu (o cualquier otra persona dueÃ±a de aparatitos electrÃ³nicos) pueda cargar a tope todos sus dispositivos en un solo comando.


DelegaciÃ³n y Polimorfismo
Sueldo de Pepe
Ejercicio basado en El sueldo de Pepe

Desarrollar los objetos necesarios para calcular el sueldo de Pepe. El sueldo de pepe se calcula asÃ­:

sueldo = sueldo base + bono x presentismo + bono x resultados.
El sueldo base es el de la categorÃ­a, hay dos categorÃ­as:

gerentes que ganan $1000 de sueldo base,
cadetes que ganan $1500.
Hay dos bonos por presentismo:

Es $100 si la persona a quien se aplica no faltÃ³ nunca, $50 si faltÃ³ un dÃ­a, $0 en cualquier otro caso;
En el otro, nada.
Hay tres posibilidades para el bono por resultados:

Un porcentaje sobre el sueldo base
Un valor fijo
O nada
Probar cambiÃ¡ndole a pepe la categorÃ­a, la cantidad de dÃ­as que falta y haciendo que cumpla sus objetivos. Probar tambiÃ©n cambiar sus bonos por presentismo y por resultados, o con nosotros empelados con diferente categorÃ­a y bonos. En cada caso preguntarle su sueldo.

>>>
>>> dani.faltar()
>>> dani.faltas
1
>>> dani.sueldo_total()
1050
>>> dani.faltar()
>>> dani.faltar()
>>> dani.faltar()
>>> dani.sueldo_total()
1000
>>>
>>> umi.sueldo_total()
1500
>>> umi.cumplir_objetivos()
>>> umi.sueldo_total()
1725.0
>>> umi.bono_resultados = BonoFijoPorResultados(80)
>>> umi.sueldo_total()
1580
>>>
Trenes y depÃ³sitos
Una administradora ferroviaria necesita una aplicacioÌn que le ayude a manejar las formaciones que tiene disponibles en distintos depoÌsitos. Una formacioÌn es lo que habitualmente llamamos â€œun trenâ€, tiene una o varias locomotoras, y uno o varios vagones. Hay vagones de pasajeros y vagones de carga. En cada depoÌsito hay: formaciones ya armadas, y locomotoras sueltas que pueden ser agregadas a una formacioÌn.

De cada vagoÌn de pasajeros se conoce el largo en metros, y el ancho uÌtil tambieÌn en metros. La cantidad de pasajeros que puede transportar un vagoÌn de pasajeros es: Si el ancho uÌtil es de hasta 2.5 metros: metros de largo * 8. Si el ancho uÌtil es de maÌs de 2.5 metros: metros de largo * 10. P.ej., si tenemos dos vagones de pasajeros, los dos de 10 metros de largo, uno de 2 metros de ancho uÌtil, y otro de 3 metros de ancho uÌtil, entonces el primero puede llevar 80 pasajeros, y el segundo puede llevar 100. Un vagoÌn de pasajeros no puede llevar carga.

De cada vagoÌn de carga se conoce la carga maÌxima que puede llevar, en kilos. Un vagoÌn de carga no puede llevar ninguÌn pasajero. No hay vagones mixtos.

El peso maÌximo de un vagoÌn, medido en kilos, se calcula asiÌ: Para un vagoÌn de pasajeros: cantidad de pasajeros que puede llevar * 80. Para un vagoÌn de carga: la carga maÌxima que puede llevar + 160 (en cada vagoÌn de carga van dos guardas).

De cada locomotora se sabe: su peso, el peso maÌximo que puede arrastrar, y su velocidad maÌxima. P.ej. puedo tener una locomotora que pesa 1000 kg, puede arrastrar hasta 12000 kg, y su velocidad maÌxima es de 80 km/h. Obviamente se tiene que arrastrar a ella misma, entonces no le puedo cargar 12000 kg de vagones, solamente 11000; diremos que este es su â€œarrastre uÌtilâ€.

Modelar la situacioÌn descripta de acuerdo al paradigma de objetos, escribiendo el coÌdigo en lenguaje Wollok, de manera de poder saber: El total de pasajeros que puede transportar una formacioÌn. CuaÌntos vagones livianos tiene una formacioÌn; un vagoÌn es liviano si su peso maÌximo es menor a 2500 kg. La velocidad maÌxima de una formacioÌn, que es el miÌnimo entre las velocidades maÌximas de las locomotoras. Si una formacioÌn es eficiente; es eficiente si cada una de sus locomotoras arrastra, al menos, 5 veces su peso (el de la locomotora misma). Si una formacioÌn puede moverse. Una formacioÌn puede moverse si el arrastre uÌtil total de las locomotoras es mayor o igual al peso maÌximo total de los vagones. CuaÌntos kilos de empuje le faltan a una formacioÌn para poder moverse, que es: 0 si ya se puede mover, y (peso maÌximo total de los vagones â€“ arrastre uÌtil total de las locomotoras) en caso contrario. Dado un depoÌsito, el conjunto formado por el vagoÌn maÌs pesado de cada formacioÌn; se espera un conjunto de vagones. Si un depoÌsito necesita un conductor experimentado. Un depoÌsito necesita un conductor experimentado si alguna de sus formaciones es compleja. Una formacioÌn es compleja si: tiene maÌs de 20 unidades (sumando locomotoras y vagones), o el peso total (sumando locomotoras y vagones) es de maÌs de 10000 kg. Agregar, dentro de un depoÌsito, una locomotora a una formacioÌn determinada, de forma tal que la formacioÌn pueda moverse. Si la formacioÌn ya puede moverse, entonces no se hace nada. Si no, se le agrega una locomotora suelta del depoÌsito cuyo arrastre uÌtil sea mayor o igual a los kilos de empuje que le faltan a la formacioÌn. Si no hay ninguna locomotora suelta que cumpla esta condicioÌn, no se hace nada.

O sea: indicar queÌ clases se necesitan, queÌ variables de instancia se necesitan en cada clase, queÌ mensajes van a entender las instancias de cada clase, y escribir los meÌtodos correspondientes. Para cada punto, indicar a queÌ objeto se le pide lo que se indica, con queÌ mensaje, queÌ paraÌmetros, y queÌ devuelve. Para el punto 8, indicar en queÌ otros objetos delega el responsable de hacer lo que se pide, y queÌ delega (indicar lo que se delega en castellano). Si hay una cadena de delegaciones (al objeto 1 le piden algo, entonces delega algo en el objeto 2, y el objeto 2 para hacer lo que le pidioÌ el 1 tiene que delegar otra cosa en otro objeto 3) indicarla.

Ejercicio 2 â€“ Mascota Virtual Modelar una mascota virtual, onda Tamagotchi, incluyendo los mensajes correspondientes a las acciones de comer y jugar, y la pregunta acerca de si puede jugar o no.

TambieÌn hay que poder conocer el nivel de contenta de una mascota, que es un nuÌmero entero mayor o igual que 0, donde a mayor nivel, maÌs contenta estaÌ la mascota.

Una mascota puede estar aburrida, hambrienta o contenta; y su comportamiento depende de en queÌ estado esteÌ. Veamos:

Cuando una mascota come, pasa lo siguiente: Si estaÌ hambrienta, se pone contenta. Si estaÌ contenta, su nivel se incrementa en una unidad. Si estaÌ aburrida, y hace maÌs de 80 minutos que estaÌ aburrida, entonces se pone contenta. Si estaÌ aburrida desde hace 80 minutos o menos, entonces no le pasa nada, no cambia nada.

Cuando una mascota juega, pasa lo siguiente: Si estaÌ contenta, su nivel se incrementa en dos unidades. Si estaÌ aburrida, se pone contenta. No produce ninguÌn efecto jugar con la mascota si estÃ¡ hambrienta.

Una mascota puede jugar si estaÌ contenta o aburrida, si estaÌ hambrienta no.

NO SE PUEDE CONSULTAR DE NINGUNA MANERA EL ESTADO ACTUAL DE LA MASCOTA. Esto quiere decir que estaÌ prohibido hacer comparaciones del tipo estado == â€œcontentoâ€ o cualquiera similar utilizando mensajes especiales.

Responder las siguientes preguntas: Indique en palabras los pasos necesarios para incorporar un nuevo estado â€œTristeâ€ en la mascota, de manera que quede listo para funcionar. Indique cuaÌl seriÌa la prueba en un test similar para darles de comer a todas las mascotas que estaÌn dentro de una coleccioÌn â€œmascotasâ€.